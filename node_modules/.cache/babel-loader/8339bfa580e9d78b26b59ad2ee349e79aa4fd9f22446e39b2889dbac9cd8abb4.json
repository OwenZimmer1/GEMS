{"ast":null,"code":"export function computeMinimumDominatingSet(graph) {\n  const allNodes = graph.nodes.map(node => node.id);\n\n  // Build adjacency list\n  const adj = new Map();\n  graph.nodes.forEach(node => adj.set(node.id, new Set()));\n  graph.edges.forEach(({\n    source,\n    target\n  }) => {\n    adj.get(source).add(target);\n    adj.get(target).add(source);\n  });\n\n  // Check if a given set of nodes is a dominating set\n  const isDominatingSet = candidate => {\n    const dominated = new Set();\n    Array.from(candidate).forEach(node => {\n      dominated.add(node);\n      adj.get(node).forEach(nbr => dominated.add(nbr));\n    });\n    return dominated.size === allNodes.length;\n  };\n\n  // Try all subsets of nodes, from smallest to largest\n  for (let size = 1; size <= allNodes.length; size++) {\n    const subsets = generateSubsets(allNodes, size);\n    for (const subset of subsets) {\n      const candidateSet = new Set(subset);\n      if (isDominatingSet(candidateSet)) return candidateSet;\n    }\n  }\n  return new Set(); // should never happen for connected graphs\n}\nfunction generateSubsets(arr, size) {\n  const result = [];\n  const backtrack = (start, path) => {\n    if (path.length === size) {\n      result.push([...path]);\n      return;\n    }\n    for (let i = start; i < arr.length; i++) {\n      path.push(arr[i]);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  };\n  backtrack(0, []);\n  return result;\n}","map":{"version":3,"names":["computeMinimumDominatingSet","graph","allNodes","nodes","map","node","id","adj","Map","forEach","set","Set","edges","source","target","get","add","isDominatingSet","candidate","dominated","Array","from","nbr","size","length","subsets","generateSubsets","subset","candidateSet","arr","result","backtrack","start","path","push","i","pop"],"sources":["/Users/owenzimmer/GEMS/src/algorithms/dominatingSet.ts"],"sourcesContent":["export type Graph = {\n  nodes: { id: string }[];\n  edges: { source: string; target: string }[];\n};\n\nexport function computeMinimumDominatingSet(graph: Graph): Set<string> {\n  const allNodes = graph.nodes.map((node) => node.id);\n\n  // Build adjacency list\n  const adj = new Map<string, Set<string>>();\n  graph.nodes.forEach((node) => adj.set(node.id, new Set()));\n  graph.edges.forEach(({ source, target }) => {\n    adj.get(source)!.add(target);\n    adj.get(target)!.add(source);\n  });\n\n  // Check if a given set of nodes is a dominating set\n  const isDominatingSet = (candidate: Set<string>): boolean => {\n    const dominated = new Set<string>();\n    Array.from(candidate).forEach((node) => {\n      dominated.add(node);\n      adj.get(node)!.forEach((nbr) => dominated.add(nbr));\n    });\n    return dominated.size === allNodes.length;\n  };\n\n  // Try all subsets of nodes, from smallest to largest\n  for (let size = 1; size <= allNodes.length; size++) {\n    const subsets = generateSubsets(allNodes, size);\n    for (const subset of subsets) {\n      const candidateSet = new Set(subset);\n      if (isDominatingSet(candidateSet)) return candidateSet;\n    }\n  }\n\n  return new Set(); // should never happen for connected graphs\n}\n\nfunction generateSubsets<T>(arr: T[], size: number): T[][] {\n  const result: T[][] = [];\n\n  const backtrack = (start: number, path: T[]) => {\n    if (path.length === size) {\n      result.push([...path]);\n      return;\n    }\n    for (let i = start; i < arr.length; i++) {\n      path.push(arr[i]);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  };\n\n  backtrack(0, []);\n  return result;\n}\n"],"mappings":"AAKA,OAAO,SAASA,2BAA2BA,CAACC,KAAY,EAAe;EACrE,MAAMC,QAAQ,GAAGD,KAAK,CAACE,KAAK,CAACC,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACC,EAAE,CAAC;;EAEnD;EACA,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAsB,CAAC;EAC1CP,KAAK,CAACE,KAAK,CAACM,OAAO,CAAEJ,IAAI,IAAKE,GAAG,CAACG,GAAG,CAACL,IAAI,CAACC,EAAE,EAAE,IAAIK,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1DV,KAAK,CAACW,KAAK,CAACH,OAAO,CAAC,CAAC;IAAEI,MAAM;IAAEC;EAAO,CAAC,KAAK;IAC1CP,GAAG,CAACQ,GAAG,CAACF,MAAM,CAAC,CAAEG,GAAG,CAACF,MAAM,CAAC;IAC5BP,GAAG,CAACQ,GAAG,CAACD,MAAM,CAAC,CAAEE,GAAG,CAACH,MAAM,CAAC;EAC9B,CAAC,CAAC;;EAEF;EACA,MAAMI,eAAe,GAAIC,SAAsB,IAAc;IAC3D,MAAMC,SAAS,GAAG,IAAIR,GAAG,CAAS,CAAC;IACnCS,KAAK,CAACC,IAAI,CAACH,SAAS,CAAC,CAACT,OAAO,CAAEJ,IAAI,IAAK;MACtCc,SAAS,CAACH,GAAG,CAACX,IAAI,CAAC;MACnBE,GAAG,CAACQ,GAAG,CAACV,IAAI,CAAC,CAAEI,OAAO,CAAEa,GAAG,IAAKH,SAAS,CAACH,GAAG,CAACM,GAAG,CAAC,CAAC;IACrD,CAAC,CAAC;IACF,OAAOH,SAAS,CAACI,IAAI,KAAKrB,QAAQ,CAACsB,MAAM;EAC3C,CAAC;;EAED;EACA,KAAK,IAAID,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAIrB,QAAQ,CAACsB,MAAM,EAAED,IAAI,EAAE,EAAE;IAClD,MAAME,OAAO,GAAGC,eAAe,CAACxB,QAAQ,EAAEqB,IAAI,CAAC;IAC/C,KAAK,MAAMI,MAAM,IAAIF,OAAO,EAAE;MAC5B,MAAMG,YAAY,GAAG,IAAIjB,GAAG,CAACgB,MAAM,CAAC;MACpC,IAAIV,eAAe,CAACW,YAAY,CAAC,EAAE,OAAOA,YAAY;IACxD;EACF;EAEA,OAAO,IAAIjB,GAAG,CAAC,CAAC,CAAC,CAAC;AACpB;AAEA,SAASe,eAAeA,CAAIG,GAAQ,EAAEN,IAAY,EAAS;EACzD,MAAMO,MAAa,GAAG,EAAE;EAExB,MAAMC,SAAS,GAAGA,CAACC,KAAa,EAAEC,IAAS,KAAK;IAC9C,IAAIA,IAAI,CAACT,MAAM,KAAKD,IAAI,EAAE;MACxBO,MAAM,CAACI,IAAI,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC;MACtB;IACF;IACA,KAAK,IAAIE,CAAC,GAAGH,KAAK,EAAEG,CAAC,GAAGN,GAAG,CAACL,MAAM,EAAEW,CAAC,EAAE,EAAE;MACvCF,IAAI,CAACC,IAAI,CAACL,GAAG,CAACM,CAAC,CAAC,CAAC;MACjBJ,SAAS,CAACI,CAAC,GAAG,CAAC,EAAEF,IAAI,CAAC;MACtBA,IAAI,CAACG,GAAG,CAAC,CAAC;IACZ;EACF,CAAC;EAEDL,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;EAChB,OAAOD,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}